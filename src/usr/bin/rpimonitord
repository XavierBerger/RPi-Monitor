#!/usr/bin/perl
#
# Copyright 2013-2018 - Xavier Berger - http://rpi-experiences.blogspot.fr/
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

  #print to_json \%{$configuration->{'config'}->{'web'}};
  #print Data::Dumper->Dump([$configuration]);

#use diagnostics;
use strict;
use IPC::ShareLite;
$|=1;
$SIG{CHLD}   = 'IGNORE';

my $VERSION  = "{DEVELOPMENT}";
our $loglevel  = 0;
my $pidfile;

package Configuration;
use strict;
use POSIX;
use Cwd 'abs_path';
use Data::Dumper;

sub new
{
  my $this = bless { }, shift;
  $this->Debug(2,"");
  $this->{'rrd'}=();
  $this->{'daemon'}->{'confFiles'} = [];
  return $this;
}

sub Debug
{
  my $this = shift;
  my $level = shift;

  $level <= $loglevel or return;
  print STDERR "[", strftime("%Y/%m/%d-%H:%M:%S", localtime), "] ", "  " x ($level), (caller 1)[3], " @_\n";
}

sub GreatestCommonDivisor
{
  my $this=shift;
  my $a = shift;
  my $b = shift;
  my $A = $a;
  my $B = $b;
  while ( $a != $b ){
    if ( $a < $b ) {
      $a += $A;
    }
    else {
     $b += $B;
    }
  }
  return $a;
}

sub Load
{
  my $this = shift;
  $this->Debug(2,"");

  $_ = abs_path($0);
  my ($path,$file) = /(.*)\/([^\/]*)$/;

  # Add default configuration file if not already defined by command line
  if ( !@{$this->{'daemon'}->{'confFiles'}} ) {
    push(@{$this->{'daemon'}->{'confFiles'}},"/etc/rpimonitor/data.conf");
    push(@{$this->{'daemon'}->{'confFiles'}},"/etc/rpimonitor/daemon.conf");
  }

  foreach ( @{$this->{'daemon'}->{'confFiles'}} ) {
    $this->LoadFile($_);
  }
  delete($this->{'daemon'}->{'confFiles'});

  # Set version (used by web pages cache mechanism)
  $this->{'version'} = localtime();

  # Load default values is not defined yet defined
  $this->{'daemon'}->{'user'}            ||= "pi";
  $this->{'daemon'}->{'group'}           ||= "pi";
  $this->{'daemon'}->{'noserver'}        ||= 0;
  $this->{'daemon'}->{'port'}            ||= 8888;
  $this->{'daemon'}->{'addr'}            ||= '0.0.0.0';
  $this->{'daemon'}->{'webroot'}         ||= "/usr/share/rpimonitor/web";
  $this->{'daemon'}->{'datastore'}       ||= "/var/lib/rpimonitor";
  $this->{'daemon'}->{'delay'}           ||= 10;
  $this->{'daemon'}->{'defaultinterval'} ||= 1;
  $this->{'daemon'}->{'readonly'}        ||= 0;
  $this->{'daemon'}->{'timeout'}         ||= 5;
  $this->{'daemon'}->{'sharedmemkey'}    ||= 20130906;
  $this->{'daemon'}->{'loglevel'}        ||= 0;
  $loglevel ||= $this->{'daemon'}->{'loglevel'};

  # Check user and group
  $this->{'daemon'}->{'gid'} = getgrnam($this->{'daemon'}->{'group'})  || 1000;
  $this->{'daemon'}->{'uid'} = getpwnam($this->{'daemon'}->{'user'}) || 1000;

  if ( ! $this->{'daemon'}->{'readonly'} ){
    # Check rrd directory and files and create them if they are missing
    # Create storage directory if needed
    -d "$this->{'daemon'}->{'datastore'}/stat" or mkdir "$this->{'daemon'}->{'datastore'}/stat";
    # Create empty file at each start
    $this->CreateRRD( "$this->{'daemon'}->{'datastore'}/stat/empty.rrd", 'empty', 'GAUGE', 'U', 'U' );
    chown($this->{'daemon'}->{'uid'},$this->{'daemon'}->{'gid'},"$this->{'daemon'}->{'datastore'}/stat/empty.rrd");
  }

  #print Data::Dumper->Dump([$this->{'daemon'}]);

  # Load default values is not defined yet defined
  $this->{'snmpagent'}->{'rootoid'}        ||= ".1.3.6.1.4.1";
  $this->{'snmpagent'}->{'enterpriseoid'}  ||= 54321;
  $this->{'snmpagent'}->{'rpimonitoroid'}  ||= 42;
  $this->{'snmpagent'}->{'mibname'}        ||= "RPIMONITOR-MIB";
  $this->{'snmpagent'}->{'lastupdate'}     ||= "201802030000Z";
  $this->{'snmpagent'}->{'moduleidentity'} ||= "rpi-experiences";
  $this->{'snmpagent'}->{'organisation'}   ||= "RPi-Monitor";
  $this->{'snmpagent'}->{'contactionfo'}   ||= "http://rpi-experiences.blogspot.fr/";
  $this->{'snmpagent'}->{'description'}    ||= "description";
  $this->{'snmpagent'}->{'revision'}       ||= "201802030000Z";

  if ( ! $this->{'daemon'}->{'readonly'} ){
    # manage rrds
    foreach (@{$this->{'rrd'}}){
      my @name = split (',',$_->{'name'});
      my $type = $_->{'rrd'};
      my $min = defined($_->{'min'}) ? $_->{'min'} : "U";
      my $max = defined($_->{'max'}) ? $_->{'max'} : "U";
      foreach (@name) {
        my $filename="$this->{'daemon'}->{'datastore'}/stat/$_.rrd";
        -f "$filename" or $this->CreateRRD($filename,$_,$type,$min,$max);
        push(@{$this->{'rrdlist'}},"stat/$_.rrd");
      }
    }
    #print Data::Dumper->Dump([$this->{'rrdlist'}]);
  }

  # manage page header default parameters
  $this->{'web'}->{'page'}->{'icon'}       ||= "img/logo.png";
  $this->{'web'}->{'page'}->{'menutitle'}  ||= "'RPi-Monitor  <sub>('+data.hostname+')</sub>'";
  $this->{'web'}->{'page'}->{'pagetitle'}  ||= "'RPi-Monitor ('+data.hostname+')'";

  # manage menu
  foreach (@{$this->{'web'}->{'status'}}) {
    $_->{'title'} and push(@{$this->{'web'}->{'menu'}->{'status'}}, $_->{'title'})
                  or  push(@{$this->{'web'}->{'menu'}->{'status'}}, "Status");
  }
  foreach (@{$this->{'web'}->{'statistics'}}) {
    $_->{'title'} and push(@{$this->{'web'}->{'menu'}->{'statistics'}}, $_->{'title'})
                  or  push(@{$this->{'web'}->{'menu'}->{'statistics'}}, "Statistics");
  }
  foreach (@{$this->{'web'}->{'addons'}}) {
    $_->{'title'} and push(@{$this->{'web'}->{'menu'}->{'addons'}}, $_->{'title'});
  }

  # manage default value for dynamic data
  $this->{'maxinterval'} = 1;
  foreach (@{$this->{'dynamic'}}) {
    $_->{'interval'} ||= $this->{'daemon'}->{'defaultinterval'};
    if ($_->{'interval'} > $this->{'maxinterval'} ) {
      $this->{'maxinterval'} = $this->GreatestCommonDivisor($this->{'maxinterval'}, $_->{'interval'});
    }
  }

  if ( $this->{'show'} ) {
    $Data::Dumper::Indent = 1;
    print Data::Dumper->Dump([$this]);
    die "loglevel = $loglevel\n";
  }

  $this->{'sharedmem'} = IPC::ShareLite->new(
        -key     => $this->{'daemon'}->{'sharedmemkey'},
        -create  => 'yes',
        -destroy => 'no'
    ) or die $!;
}

sub LoadFile
{
  my $this = shift;
  my $confFile = shift;
  my @dict;
  $this->Debug(3,"Loading file: $confFile");

  open (FILE, $confFile)
    or die "Error while openning configuration file \"$confFile\" because $!\n";
  while (<FILE>){
    chomp;
    /^\s*#|^$/ and next;                 # Ignore comments
    /^include=(.*)/ and -f $1 and push(@{$this->{'daemon'}->{'confFiles'}}, $1) and next;
    my ($key, $value) = /^([^=]*)=(.*)/; # Extract key and value
    my @leaves=split('\.', $key);        # Explode key and construct config hash
    my $tree=$this;
    my $previous;
    my $current;
    my $next;
    my $root;
    my $page = 0;                         # page = 0 for static and dynamic
    while (scalar(@leaves) > 0) {         # While @leaves contains data
      $current ||= shift (@leaves);       # If root is empty, shift the first element of @leaves to $current
      $root ||= $current;
      if ( ( $root eq 'alert' ) || ( $root eq 'web' ) ) { $root = $current }
      $next = shift (@leaves);            # Shift the first element of @leaves in $next
      if ( $next =~ /^\d+$/ ) {           # If $next is an integer -> we are in an array
        if ($current =~ /^\d+$/) {        # If $current is an integer -> we are in an array
          @{$tree}[$current-1] ||= [];    # If the branch is not an array, create an empty array
          $tree=@{$tree}[$current-1];     # Define this array as $tree root
        }
        else {
          $tree->{$current} ||= [];       # If the branch is not an array, create an empty array
          $tree=$tree->{$current};        # Define this array as $tree root
        }
      } else {                            # If $next is not an integer -> We are in a hash
        if ($current =~ /^\d+$/) {        # If $current is an integer -> we are in an array
          my $index = $current;

          if ( ($previous eq 'status' )    ||
               ($previous eq 'statistics' ) )
          {
            $page=$current;
          }
          # Manage per file indexes unicity
          if ( ($root eq "addons")            ||
               ($root eq "static")            ||
               ($root eq "dynamic")           ||
               ( ( ($root eq 'status' )       ||
                   ($root eq 'statistics' ) ) &&
                 ($previous eq "content") ) )
          {
            # If $index is not in $dict, add it with counter++
            if ( ! $dict[$page]->{$root}[$current] )
            {
              $dict[$page]->{$root}[$current] = ++$this->{'counter'}[$page]->{$root};
            }
            $index = $dict[$page]->{$root}[$current];
          }

          @{$tree}[$index-1] ||= {};      # If the branch is not an array, create an empty hash
          $tree=@{$tree}[$index-1];       # Define this hash as $tree root
        }
        else {                            # We are in a hash
          $tree->{$current} ||= {};       # If the branch is not an array, create an empty hash
          $tree=$tree->{$current};        # Define this hash as $tree root
        }
      }
      if ( ($next eq 'rrd') and $value) { push(@{$this->{'rrd'}},$tree) };
      $previous = $current;
      $current = $next;
    }

    # Add value
    if ($current =~ /^\d+$/) {
      @{$tree}[$current-1] = $value;
    }
    else {
      $tree->{$current} = $value;
    }
  }
}

sub CreateRRD
{
  my $this = shift;
  my $filename = shift;
  my $name = shift;
  my $type = shift;
  my $min = shift;
  my $max = shift;
  $this->Debug(3,"$filename - $name - $type - $min < value < $max");

  my $current = time();
  my $start = $current - 60;

  unlink $filename;

  $this->Debug(4,"$filename",
                "--start", $start,
                "--step", $this->{'daemon'}->{'delay'},
                "DS:$name:$type:600:$min:$max",
                "RRA:AVERAGE:0.5:1:8640",    # 1 day with interval of 10sec
                "RRA:AVERAGE:0.5:6:2880",    # 2 day with interval of 1min
                "RRA:AVERAGE:0.5:60:2016",   # 2 week with interval of 10min
                "RRA:AVERAGE:0.5:180:1488",  # 1 mounth with interval of 30min
                "RRA:AVERAGE:0.5:360:8784"   # 1 year with interval of 1hour
                );

  RRDs::create( "$filename",
                "--start", $start,
                "--step", $this->{'daemon'}->{'delay'},
                "DS:$name:$type:600:$min:$max",
                "RRA:AVERAGE:0.5:1:8640",    # 1 day with interval of 10sec
                "RRA:AVERAGE:0.5:6:2880",    # 2 day with interval of 1min
                "RRA:AVERAGE:0.5:60:2016",   # 2 week with interval of 10min
                "RRA:AVERAGE:0.5:180:1488",  # 1 mounth with interval of 30min
                "RRA:AVERAGE:0.5:360:8784"   # 1 year with interval of 1hour
                );
}

package Server;
use strict;
use POSIX;
use IO::Handle;
use HTTP::Daemon;
use HTTP::Status;
use JSON -convert_blessed_universally;
use MIME::Base64;
#use Data::Dumper;

sub new
{
  my $this = bless {}, shift;
  $this->Debug(2,"");

  return $this;
}

sub Debug
{
  my $this = shift;
  my $level = shift;

  $level <= $loglevel or return;
  print STDERR "[", strftime("%Y/%m/%d-%H:%M:%S", localtime), "] ", "  " x ($level), (caller 1)[3], " @_\n";
}

sub SendFile
{
  my $this = shift;
  my $connection = shift;
  my $file = shift;
  $this->Debug(2,$file);

  $connection->send_file_response($file);
  $connection->close();

  return 1;
}

sub SendJSON
{
  my $this = shift;
  my $message =shift;

  my $response = HTTP::Response->new(
      RC_OK, OK => [ 'Content-Type' => "application/json" ], $message
  );
  $this->{'connection'}->send_response($response);
  $this->{'connection'}->close();

  return 1;
}

sub SendStatus
{
  my $this = shift;
  my $configuration = shift;
  $this->Debug(2,"");

  my $var = $configuration->{'sharedmem'}->fetch();

  $var =~ s/\s+$//g;
  $this->Debug(3,"JSON: $var");
  $this->SendJSON($var);

  return 1;
}

sub SendRedirect
{
  my $this = shift;
  my $destination = shift;
  $this->Debug(2,$destination);

  $this->{'connection'}->send_redirect($destination, 302);
  $this->{'connection'}->close();

  return 1;
}

sub SendError
{
  my $this=shift;
  my $errorcode= shift;
  $this->Debug(2,$errorcode);

  $this->{'connection'}->send_error($errorcode);
  $this->{'connection'}->close();

  return 1;
}

sub SendChallenge
{
  my $this=shift;
  $this->Debug(2,"Challenge auth");
  my $response = HTTP::Response->new( 
    401 => 'Authorization Required',
    [ 'WWW-Authenticate' => 'Basic realm="Identity"',
      'Content-Type' => "text/plain"],
    "Authentication needed"
  );
  $this->{'connection'}->send_response($response);
  $this->{'connection'}->close();
}

sub CheckChallenge
{
  my $this = shift;
  my $request = shift;
  my $auth_received = shift;
  my $configuration = shift;
  my $auth = "Basic ".encode_base64($configuration->{'daemon'}->{'basicauth'}, '');
  if ($auth eq $auth_received)
  {
    return 1;
  }
  else
  {
    $this->Debug(1, "Bad authent provided");
    return 0;
  }
}

sub DoGET
{
  my $this = shift;
  my $request = shift;
  my $configuration = shift;
  $this->Debug(2,"");

  my $connection = $this->{'connection'};
  $_ = $request->url->path;
  my $path = $_;
  $this->Debug(2, "$path");

  #The file need to be known or we return an error
  my $isvalid;
  foreach(@{$this->{'paths'}}) {
    if ( $path =~ /$_$/ ){
      $isvalid=1;
      $path=$_;
      last;
    }
  }

  if( ! $configuration->{'daemon'}->{'readonly'}) {
    # Check if requested RRD exists, if not, send empty.rrd
    if ( $path =~ /\.rrd$/) {
      if ( ! -f "$configuration->{'daemon'}->{'datastore'}/$path" ) {
        $this->Debug(3, "$configuration->{'daemon'}->{'datastore'}/$path is not existing, sending empty.rrd");
        $path = '/stat/empty.rrd';
        $isvalid=1;
      }
    }

    # Check for valid addon
    if ( $path =~ /\/addons\/(.*)\/(.*)\.(js|html|css)/ ) {
      $path = "/addons/$1/$2.$3";
      $isvalid=1;
    }
  }

  #$isvalid or $connection->send_error(404,"<br><b>$path</b> not in <br>". join ('<br>',@{$this->{'paths'}} )) and return;
  $isvalid or $this->SendError(404);

  $path =~ /dynamic\.json/  and $this->SendStatus( $configuration ) and return;
  $path =~ /static\.json/  and $this->SendJSON($this->{'static'}) and return;
  
  if( ! $configuration->{'daemon'}->{'readonly'}) {
    $path =~ /([^\/]+)\.json/ and $this->SendJSON($this->{$1}) and return;
    
    #If requested rrd doesn't exist, return empty.rrd
    $path =~ /rrd$/ and ! -f "$configuration->{'daemon'}->{'datastore'}/$path" and $path="empty.rrd";

    #Recreate empty rrd on demand
    $path =~ /empty\.rrd/ and $configuration->CreateRRD( "$configuration->{'daemon'}->{'datastore'}/stat/empty.rrd", 'empty', 'GAUGE', 'U', 'U' );

    #The main page (/) is requested
    $path =~ /^\/$/ and $path = "/index.html";

    #Disable index page (until login screen is implemented)
    $path =~ /index\.html/ and $path =~ s/index/status/;

    #If the file exists we return it
    -f "$configuration->{'daemon'}->{'webroot'}/$path" and $this->SendFile($connection, "$configuration->{'daemon'}->{'webroot'}/$path") and return;
    -f "$configuration->{'daemon'}->{'datastore'}/$path" and $this->SendFile($connection, "$configuration->{'daemon'}->{'datastore'}/$path") and return;
  }

  $this->Debug(2,"Can't find $path");

  #Finally send error
  $this->SendError();
}

sub Run
{
  my $this = shift;
  my $configuration=shift;
  my $monitor=shift;
  $this->Debug(3,"");

  # List of files to be delivered
  my @paths = (
    "/static.json",
    "/dynamic.json"
  );
    
  if ( ! $configuration->{'daemon'}->{'readonly'} ) {
    @paths = ( @paths, (
      "/",
      "/all.json",
      "/addons.json",
      "/status.json",
      "/statistics.json",
      "/menu.json",
      "/friends.json",
      "/page.json",
      "/version.json",
      "/favicon.ico",

      "/index.html",
      "/addons.html",
      "/statistics.html",
      "/status.html",
      "/cacert.pem",
      "/certificate.p12",

      "/css/rpimonitor.css",
      "/css/bootstrap.min.css",

      "/fonts/glyphicons-halflings-regular.eot",
      "/fonts/glyphicons-halflings-regular.ttf",
      "/fonts/glyphicons-halflings-regular.svg",
      "/fonts/glyphicons-halflings-regular.woff",

      "/stat/empty.rrd",

      "/img/preloader.gif",

      "/js/rpimonitor.statistics.js",
      "/js/rpimonitor.status.js",
      "/js/rpimonitor.utils.js",
      "/js/rpimonitor.addons.js",
      "/js/rpimonitor.index.js",
      "/js/rpimonitor.js",
      "/js/jsqrencode.min.js",
      "/js/raphael.2.1.0.min.js",
      "/js/justgage.1.0.1.min.js",
      "/js/jquery.min.js",
      "/js/bootstrap.min.js",
      "/js/flot/jquery.flot.min.js",
      "/js/flot/jquery.flot.selection.min.js",
      "/js/flot/jquery.flot.tooltip.min.js",
      "/js/javascriptrrd/binaryXHR.js",
      "/js/javascriptrrd/rrdFlotMatrix.js",
      "/js/javascriptrrd/rrdFlot.js",
      "/js/javascriptrrd/rrdFilter.js",
      "/js/javascriptrrd/rrdMultiFile.js",
      "/js/javascriptrrd/rrdFile.js",
      "/js/javascriptrrd/rrdFlotSupport.js",
      "/js/Sortable.1.6.1.min.js"
    ));
  }
  $this->{'paths'} = \@paths;

  # Add rrds available and status file to the authorized pages
  foreach (glob("$configuration->{'daemon'}->{'webroot'}/img/*.png")){
    /(img\/.*\.png)$/;
    unshift ( @{$this->{'paths'}}, $1);
  }
  if ( ! $configuration->{'daemon'}->{'readonly'} ) { 
    $configuration->{'rrdlist'} and @{$this->{'paths'}} = ( @{ $configuration->{'rrdlist'}}, @{$this->{'paths'}} );
  }
  $this->{'status'} = to_json(\@{$configuration->{'web'}->{'status'}});
  $this->{'statistics'} = to_json(\@{$configuration->{'web'}->{'statistics'}});
  $this->{'friends'} = to_json(\@{$configuration->{'web'}->{'friends'}});
  $this->{'page'} = to_json(\%{$configuration->{'web'}->{'page'}});
  $monitor->{'static'}->{'alert'} = $configuration->{'alert'};
  $this->{'static'} = to_json(\%{$monitor->{'static'}});
  $this->{'menu'} = to_json(\%{$configuration->{'web'}->{'menu'}});
  $this->{'addons'} = to_json(\@{$configuration->{'web'}->{'addons'}});
  my $json = JSON->new;
  $json = $json->allow_blessed([$configuration]);
  $json = $json->convert_blessed([$configuration]);
  $this->{'all'} = $json->encode( \%{$configuration} );
  $this->{'version'} = "{\"version\":\"$configuration->{'version'}\"}";
  #print Data::Dumper->Dump([$this->{'paths'}]);

  # Create the server
  $this->{'server'} = new HTTP::Daemon     ( ReuseAddr => 1,
                                             Listen => SOMAXCONN,
                                             LocalAddr => $configuration->{'daemon'}->{'addr'},
                                             LocalPort => $configuration->{'daemon'}->{'port'})
    or die "Web server not started because of error: $!\n";

  $this->Debug(1,"< URL:", $this->{'server'}->url, ">");

  setgid($configuration->{'daemon'}->{'gid'});
  setuid($configuration->{'daemon'}->{'uid'});

  #Process requests
  for (;;){
    while ( $this->{'connection'} = $this->{'server'}->accept) {
      while (my $request = $this->{'connection'}->get_request) {
        if ($configuration->{'daemon'}->{'basicauth'}) {
          # Basic authen enabled
          if ($request->header( 'Authorization' )) {
            my $auth = $request->header( 'Authorization' );
            if ($this->CheckChallenge($request, $auth, $configuration)) {
              my $method = "Do".$request->method();
              $this->can($method) and $this->$method($request,$configuration);
            }
            else {
              $this->SendChallenge();
            }
          }
          else {
            $this->SendChallenge();
          }
        }
        else {
          # Basic auth not enabled
          my $method = "Do".$request->method();
          $this->can($method) and $this->$method($request,$configuration);
        }
      }
      $this->{'connection'}->close;
      undef($this->{'connection'});
    }
  }
  $this->Debug(1,"Server stopped");

  $this->{'server'}->close();
}

package Monitor;
use strict;
use POSIX;
use RRDs;
use JSON;
use Scalar::Util qw(looks_like_number);
use File::Which;
#use Data::Dumper;

sub new
{
  my $this = bless { }, shift;
  $this->Debug(2,"");
  @{$this->{'files'}} = ("static.json","status.json","statistics.json");
  $this->{'counter'} = 0;
  return $this;
}

sub Debug
{
  my $this = shift;
  my $level = shift;

  $level <= $loglevel or return;
  print STDERR "[", strftime("%Y/%m/%d-%H:%M:%S", localtime), "] ", "  " x ($level), (caller 1)[3], " @_\n";
}

eval 'sub IPC_CREAT {0001000}' unless defined &IPC_CREAT;
eval 'sub IPC_RMID {0}'        unless defined &IPC_RMID;

sub Run
{
  # start main loop
  my $this = shift;
  my $configuration = shift;
  my $serverpid = shift;
  $this->Debug(2,"");

  if ($configuration->{'daemon'}->{'noserver'}) {
    if (! $configuration->{'daemon'}->{'readonly'}) {
      # write json if server is not running
      open(FILE, "> $configuration->{'daemon'}->{'webroot'}/static.json")
        or warn $!;
        print FILE to_json \%{$this->{'static'}} ;
      close(FILE);
      open(FILE, "> $configuration->{'daemon'}->{'webroot'}/status.json")
        or warn $!;
        print FILE to_json \@{$configuration->{'web'}->{'status'}} ;
      close(FILE);
      open(FILE, "> $configuration->{'daemon'}->{'webroot'}/page.json")
        or warn $!;
        print FILE to_json \%{$configuration->{'web'}->{'page'}} ;
      close(FILE);
      open(FILE, "> $configuration->{'daemon'}->{'webroot'}/statistics.json")
        or warn $!;
        print FILE to_json \@{$configuration->{'web'}->{'statistics'}} ;
      close(FILE);
      open(FILE, "> $configuration->{'daemon'}->{'webroot'}/friends.json")
        or warn $!;
        print FILE to_json(\@{$configuration->{'web'}->{'friends'}});
      close(FILE);
      open(FILE, "> $configuration->{'daemon'}->{'webroot'}/menu.json")
        or warn $!;
        print FILE to_json(\%{$configuration->{'web'}->{'menu'}});
      close(FILE);
      open(FILE, "> $configuration->{'daemon'}->{'webroot'}/addons.json")
        or warn $!;
        print FILE to_json(\@{$configuration->{'web'}->{'addons'}});
      close(FILE);
      open(FILE, "> $configuration->{'daemon'}->{'webroot'}/version.json")
        or warn $!;
        print FILE  "{\"version\":\"$configuration->{'version'}\"}";
      close(FILE);
    }
  }

  #die Data::Dumper->Dump([$this]);

  $this->{'counter'} = $configuration->{'maxinterval'}-1;
  for(;;)
  {
    # count loops
    $this->{'counter'}++;

    # Process data
    $this->Process($configuration,'dynamic');

    # Check alerts
    $this->Alert($configuration);

    # Store and show extracted data
    $this->Status($configuration);

    if ($this->{'counter'} >= $configuration->{'maxinterval'}){
      $this->{'counter'} = 0;
    }

    # Check if server is up
    if ( !$configuration->{'daemon'}->{'noserver'}) {
      kill(0,$serverpid) or last;
    }

    # tempo before next process
    $configuration->{'daemon'}->{'delay'} or last;
    sleep $configuration->{'daemon'}->{'delay'};
  }
  foreach (@{$this->{'files'}}) {
    -f "$configuration->{'daemon'}->{'datastore'}/$_"
      and unlink "$configuration->{'daemon'}->{'datastore'}/$_";
  }
}

sub ParseCommand
{
  my $this = shift;
  my $configuration = shift;
  my $file = shift;
  $this->Debug(2,"Parsing command '$file'");
  $_ = $file;

  while ( /data\.alert\.(\w+)\.(\w+)/ ) {
    my $data = $configuration->{'alert'}->{$1}->{$2};
    $data = defined $data ? $data :  $this->{'dynamic'}->{'alert'}->{$1}->{$2};
    $file =~ s/data\.alert\.$1\.$2/$data/;
    $_ = $file;
  }
  while ( /data\.(\w+)/ ) {
    my $data = $this->{'dynamic'}->{$1};
    $data = defined $data ? $data : $this->{'static'}->{$1};
    $file =~ s/data\.$1/$data/;
    $_ = $file;
  }

  $this->Debug(3,"Parsed command '$_'");

  return $_;
}

sub Process
{
  my $this = shift;
  my $configuration = shift;
  my $list = shift;
  $this->Debug(2,"Processing $list");

  foreach my $kpi ( @{$configuration->{$list}} ) {
    $kpi or next;
    if ( $list =~ /dynamic/) {
      $this->{'counter'} % $kpi->{'interval'} and next;
    }
    # if file is executable, execute it and process output else, read file content
    my $file = $kpi->{'source'};
    $file =~ /^(\S+)/;
    if ( (-x $1) || ( which($1) ) ) {
      $file = "$file 2>/dev/null |";
      $_ = $kpi->{'source'};
      $file = $this->ParseCommand($configuration,$file);
    }

    $this->Debug(4,"Opening '$file'");
    my $pid = 0;
    eval {
      local $SIG{ALRM} = sub { die "Timeout\n" };
      alarm $configuration->{'daemon'}->{'timeout'};

      # Extract dynamic data
      my @values;
      $pid = open(FEED, $file);
      while (<FEED>){
        /$kpi->{'regexp'}/ and (@values = /$kpi->{'regexp'}/) or next;
      }
      close(FEED);
      alarm 0;
      $pid = 0;

      # Store dynamic data
      my $i=0;
      my @postprocess = split(',',$kpi->{'postprocess'});
      my @default = split(',',$kpi->{'default'} );
      my @names = split(',',$kpi->{'name'});
      foreach ( @names ) {
        my $val = $values[$i];
        # Post process
        if ( defined($val) ) {
          if ( $postprocess[$i] ) {
            $val =~ /(.*)/;
            $val = eval( $postprocess[$i] );
          }
        }
        else {
          # Set default value is no data is present
          $val = $default[$i];
        }
        $this->{$list}->{$names[$i]}=$val;
        $i++;
      }
    };
    $pid and kill( 9, $pid);
  }
  #print Data::Dumper->Dump([$list]);
  #print Data::Dumper->Dump([$this->{'dynamic'}]);
}

sub SendAlarm
{
  my $this = shift;
  my $configuration = shift;
  my $commandline = shift;
  $this->Debug(2,"");

  $commandline = $this->ParseCommand($configuration, $commandline);

  $this->Debug(4,"Executing command: $commandline");
  my $pid = 0;
  eval {
    local $SIG{ALRM} = sub { die "Timeout\n" };
    alarm $configuration->{'daemon'}->{'timeout'};
    $pid = open(CMD, "$commandline |") or die "Can't execute $commandline because $!\n";
    close(CMD);
    alarm 0;
    $pid = 0;
  };
  $pid and kill( 9, $pid);
}

sub Status
{
  my $this = shift;
  my $configuration = shift;
  $this->Debug(2,"");

  $this->{'dynamic'} or return;

  my ($sec,$min,$hour,$mday,$mon,$year) = (localtime)[0,1,2,3,4,5];
  @{$this->{'dynamic'}->{'localtime'}}=($year+1900,$mon+1,$mday,$hour,$min,$sec);

  my $json=to_json \%{$this->{'dynamic'}};

  $this->Debug(4,"\n$json");

  # write current status (JSON) in shared memory
  $configuration->{'sharedmem'}->store( $json );

  # If embeded server is not used and not readonly, write the json file on disk
  if ( ( $configuration->{'daemon'}->{'noserver'} ) 
    && ( ! $configuration->{'daemon'}->{'readonly'} ) ){
    push (@{$this->{'files'}},"dynamic.json");
    open(FILE, "> $configuration->{'daemon'}->{'webroot'}/dynamic.json")
      or warn $!;
      print FILE $json ;
    close(FILE);
  }

  if ( ! $configuration->{'daemon'}->{'readonly'} ){
    # add data in round robin database
    #print Data::Dumper->Dump($configuration->{'rrd'});
    foreach (@{$configuration->{'rrd'}}){
      foreach my $name ( split(',',$_->{'name'}) ) {
        if ( looks_like_number( $this->{'dynamic'}->{$name} ) ) {
          RRDs::update("$configuration->{'daemon'}->{'datastore'}/stat/$name.rrd", "N:".$this->{'dynamic'}->{$name});
        }
        else {
          RRDs::update("$configuration->{'daemon'}->{'datastore'}/stat/$name.rrd", "N:U");
        }
      }
    }
  }
}

sub Alert
{
  my $this = shift;
  my $configuration = shift;
  $this->Debug(2,"");

  #print Data::Dumper->Dump([$configuration->{'alert'}]);

  while( my ( $alertname, $alertconf) = each %{$configuration->{'alert'}} ) {
      defined ($alertconf->{'active'}) or  $alertconf->{'active'}= 1;
      eval($this->ParseCommand($configuration,$alertconf->{'active'})) or next;

      $this->{'dynamic'}->{'alert'}->{$alertname} ||= {};
      my $alert = $this->{'dynamic'}->{'alert'}->{$alertname};
      $alert->{'currentalertdate'}  ||= 0;
      $alert->{'alertstate'}        ||= 0;
      $alert->{'lastsendalertdate'} ||= 0;
      $alert->{'currentcanceldate'} ||= 0;

      # Check the state of the alert
      if ( eval( $this->ParseCommand($configuration,$alertconf->{'trigger'}) ) ){
        # Alert is active
        # If the state changed, remember the date of change
        if ( $alert->{'alertstate'} != 1 ) {                                              # Previous alert state was OK
          $alert->{'currentalertdate'} = time;                                            # Remember when alert occurs
          $alert->{'alertstate'} = 1;                                                     # Current alert state is alert
          $this->Debug(3,"Alert just raised for '$alertname' : $this->{'dynamic'}->{$alertconf->{'kpi'}}$alertconf->{'comparator'}$alertconf->{'limit'}");
        }
        # Alert state exceed max duration: Houston, we have a problem
        if ( time > $alert->{'currentalertdate'} + $alertconf->{'maxalertduration'}){     # Alert duration exceed max duration
          if ( time > $alert->{'lastsendalertdate'} + $alertconf->{'resendperiod'}){      # Shall we send and alert?
            $this->Debug(3,"Sending alert command for '$alertname'");
            $this->SendAlarm($configuration,$alertconf->{'raisecommand'});
            $alert->{'lastsendalertdate'}=time;                                           # When lastsendalertdate is set, an alert is on going
          }
        }
      }
      else {
        # Alert is not active
        if ( $alert->{'alertstate'} != 0 ) {                                              # Previous alert state was 1:  KO
          $alert->{'currentcanceldate'} = time;                                           # Remerber when cancel occurs
          $alert->{'alertstate'} = 0;                                                     # Current alert state is 0: OK
          $this->Debug(3,"Alert just cancelled for '$alertname' : $this->{'dynamic'}->{$alertconf->{'kpi'}}$alertconf->{'comparator'}$alertconf->{'limit'}");
        }
        # If alert was active (lastsendalertdate !=0) and now, inactive duration exceed validation time
        if ( ( $alert->{'lastsendalertdate'} != 0) &&                                     # lastsendalertdate is set, an alert is on going
             ( time > $alert->{'currentcanceldate'} + $alertconf->{'cancelvalidation'})){ # Cancel duration is long enough
          $this->Debug(3,"Sending cancel command for '$alertname'");
          $this->SendAlarm($configuration,$alertconf->{'cancelcommand'});
          $alert->{'lastsendalertdate'} = 0;                                              # No more ongoing alert, reset times
          $alert->{'currentalertdate'}  = 0;
          $alert->{'currentcanceldate'} = 0;
        }
      }
  }
}



package Interactive;
use strict;
use POSIX;
use File::Which;

sub new
{
  my $this = bless { }, shift;
  $this->Debug(2,"");
  return $this;
}

sub Debug
{
  my $this = shift;
  my $level = shift;

  $level <= $loglevel or return;
  print STDERR "[", strftime("%Y/%m/%d-%H:%M:%S", localtime), "] ", "  " x ($level), (caller 1)[3], " @_\n";
}

sub Title
{
  my $this = shift;
  system("clear");
  print "**********************************************************************\n";
  print "*           RPi-Monitor Interactive Configuration Helper             *\n";
  print "**********************************************************************\n";
}

sub Welcome
{
  my $this = shift;
  print " RPi-Monitor Interactive is a tool to help you to define the\n";
  print " parameter of the configuration file: source, regexp, postprocess\n";
  print " and type\n";
  print "\n";
  print " Press [Enter] to continue: ";
}

sub GetSource
{
  my $this = shift;
  my $prevAnswer = shift;
  print " First you have to define the source. The source can be a file or a\n";
  print " command to be executed.\n";
  print "\n";
  print " If source is a command, RPi-Monitor executes this command and parse\n";
  print " <STDOUT>. If you need to parse <STDERR> add 2>&1 at the end of the\n";
  print " command to redirect <STDERR> to <STDOUT>.\n";
  print "\n";
  print " If the source is a flat file, RPi-Monitor parses it line by line.\n";
  print "\n";
  print " Enter here the command or the file to use as source [$prevAnswer]: \n ";
}

sub Executable
{
  my $this = shift;
  my $executable = shift;
  my $command = shift;
  $this->Title();
  print " Find executable file: '$executable'\n";
  print " Is that correct? Yes/No [Yes]: ";
  $_=<>;
  /^n(?:o)?$/i and return 0;
  print "\n Execution of the command '$command' returns:\n\n";
  system($command);
  print "\n Is that the expected output? Yes/No [Yes]: ";
  $_=<>;
  /^n(?:o)?$/i and return 0;
  return 1;
}

sub FlatFile
{
  my $this = shift;
  my $file = shift;
  $this->Title();
  print " '$file' is a flat file\n";
  print " Is that correct? Yes/No [Yes]: ";
  $_=<>;
  /^n(?:o)?$/i and return 0;
  return 1;
}

sub GetRegExp
{
  my $this = shift;

  $this->Title();
  print " The Regular Expression is here to extract the information from the\n";
  print " source. To learn Perl Regular Expression you can refer to the\n";
  print " documentation: http://perldoc.perl.org/perlretut.html \n";
  print " It is required to put the value to extract into parenthesis.\n";
}

sub ApplyRegExp
{
  my $this = shift;
  my $source = shift;
  my $regexp = shift;
  my $print = shift;

  $source =~ /^(\S+)/;
  my $file = ( -x $1 || -x which($1) ) ? "$source 2>/dev/null|" : $source;
  open(FEED, $file) or die "Can't open $file because $!\n";
  while (<FEED>){
    @_=/$regexp/ or next;
    my $i=0;
    foreach ( @_ ) {
      $i++;
      if ( $print ) {
        print " \$$i = $_\n";
      }
      else {
        close(FEED);
        return $_;
      }
    }
  }
  close(FEED);
}

sub CheckRegExp
{
  my $this = shift;
  my $source = shift;
  my $regexp = shift;

  $this->Title();
  my $test = eval { qr/$regexp/ };
  if ( $@ ) {
    print "The regular expression is not correct:\n";
    print "\n $@";
    print "\n";
    print " Press [Enter] to continue: ";
    <>;
  }
  else {
    print " Applying the Regular Expression '$regexp'\n";
    print " on the source '$source' gives the following result:\n\n";
    $this->ApplyRegExp($source,$regexp,1);
    print "\n Is that correct? Yes/No [No]: ";
    $_=<>;
    /^Y(?:es)?$/i and return 1;
  }
  return 0;
}

sub GetFormula
{
  my $this = shift;

  $this->Title();
  print " The post processing formula is designed to adjust the value extracted\n";
  print " by the regular expression. This value is accessible using \$1 \n";
  print " \n";
}

sub CheckFormula
{
  my $this = shift;
  my $source = shift;
  my $regexp = shift;
  my $formula = shift;

  $this->Title();
  print " After applying the post precessing formule, the result is: \n\n";
  $_ = $this->ApplyRegExp($source,$regexp,0);
  /(.*)/;
  print eval($formula);
  print "\n\n Is that correct? Yes/No [No]: ";
  $_=<>;
  /^Y(?:es)?$/i and return 1;

  return 0;

}

sub GetType
{
  my $this = shift;

  $this->Title();
  print " RPi-Monitor manage 2 types of data; static or dynamic.\n";
  print " static data are not changing over the time like disk size.\n";
  print " dynamic data can change over the time like disk usage.\n";
  print "\n";
  print " Is is a static data? [Yes]";
  $_=<>;
  return /^N(?:o)?$/i ? "dynamic" : "static";
}

sub PrintConfiguration
{
  my $this = shift;
  my $source = shift;
  my $regexp = shift;
  my $formula = shift;
  my $type = shift;

  my $configuration = Configuration->new();
  $configuration->Load();
  my $id = ( scalar @{$configuration->{$type}} ) + 1;

  $this->Title();
  print " We have now defined all the parameters allowing RPi-Monitor to\n";
  print " extract the data from the system. Here is a template of configuration\n";
  print " base on your actual configuration.\n";
  print "\n";
  print "$type.$id.name=<Add here the name>\n";
  print "$type.$id.source=$source\n";
  print "$type.$id.regexp=$regexp\n";
  print "$type.$id.postprocess=$formula\n";
  $_ = $type;
  /dynamic/ and print "dynamic.$id.rrd=<Define the rrd type>\n";
  print "\n You now have to copy it into an existing configuration file or\n";
  print " add a new file into /etc/rpimonitor/.\n";
  print " <Note the some text require a manual update>\n";
  print " Once the configuration will be apply, restart RPi-Monitor with the\n";
  print " command: /etc/init.d/rpimonitor restart or systemctl restart rpimonitord\n";
}

sub Run
{
  my $this = shift;

  # Show welcome page
  $this->Title();
  $this->Welcome();
  <>;

  # Get the source
  my $source="";
  for (;;) {
    $this->Title();
    $this->GetSource($source);
    $_ =<>;
    chomp;
    $source = $_ || $source;

    $source =~ /^(\S+)/;
    ( -x $1 || -x which($1) ) and $this->Executable( $1, $source ) and last;

    -f $source and $this->FlatFile($source) and last;
  }

  # Get the regular expression
  $this->Title();
  $this->GetRegExp();
  my $regexp="(.*)";
  for (;;) {
    print "\n";
    print " Enter your regular expression /$regexp/:";
    $_=<>;
    chomp;
    $regexp = $_ || $regexp;
    $this->CheckRegExp($source,$regexp) and last;
  }

  # Get post processing formula
  $this->Title();
  $this->GetFormula();
  my $formula="";
  for (;;) {
    print "\n";
    print " Enter your formula [$formula]:";
    $_=<>;
    chomp;
    $formula = $_ || $formula;
    $this->CheckFormula($source,$regexp,$formula) and last;
  }

  # Get type static or dynamic
  my $type = $this->GetType();

  # Print configuration
  $this->PrintConfiguration( $source, $regexp, $formula, $type );

  exit();
}


package SnmpModule;
use strict;
use IPC::ShareLite;
use SNMP::Extension::PassPersist;
use Scalar::Util qw(looks_like_number);
use POSIX;
use JSON;
use Data::Dumper;

sub new
{
  my $this = bless { }, shift;
  $this->Debug(2,"");
  return $this;
}

sub Debug
{
  my $this = shift;
  my $level = shift;

  $level <= $loglevel or return;
  print STDERR "[", strftime("%Y/%m/%d-%H:%M:%S", localtime), "] ", "  " x ($level), (caller 1)[3], " @_\n";
}

sub GetMib()
{
    my $this = shift;
    my $configuration = shift;

    my $snmpagent = $configuration->{'snmpagent'};
    my $mib = 
      "$snmpagent->{'mibname'} DEFINITIONS ::= BEGIN\n".
      "\n".
      "IMPORTS\n".
      "OBJECT-TYPE, MODULE-IDENTITY, enterprises, Integer32 ,TimeTicks\n".
      "FROM SNMPv2-SMI\n".
      "MODULE-COMPLIANCE,OBJECT-GROUP FROM SNMPv2-CONF;\n".
      "\n".
      "rpiexperiences MODULE-IDENTITY\n".
      "LAST-UPDATED \"$snmpagent->{'lastupdate'}\"\n".
      "ORGANIZATION \"$snmpagent->{'organisation'}\"\n".
      "CONTACT-INFO \"$snmpagent->{'contactionfo'}\"\n".
      "DESCRIPTION \"$snmpagent->{'description'}\"\n".
      "REVISION \"$snmpagent->{'revision'}\"\n".
      "DESCRIPTION \"$snmpagent->{'description'}\"\n".
      "::={ enterprises $snmpagent->{'enterpriseoid'} }\n".
      "\n".
      "rpimonitor OBJECT IDENTIFIER ::= { rpiexperiences $snmpagent->{'rpimonitoroid'}}\n".
      "";

    my $snmp = $configuration->{'snmp'};
    foreach my $key (keys %{$snmp}) {
      ( my $name = $key ) =~ s/_//;
      $mib .=
        "$name OBJECT-TYPE\n".
        "SYNTAX ".$snmp->{"$key"}->{'type'}."\n".
        "MAX-ACCESS read-only \n".
        "STATUS current\n".
        "DESCRIPTION\n".
        "\"".$snmp->{"$key"}->{'description'}."\"\n".
        "::= { rpimonitor ".$snmp->{"$key"}->{'id'}." }\n".
        "\n";
    }
 
    $mib .= "END\n";

    print $mib;
}

sub UpdateTree 
{
    my ($self) = @_;
 
    sub AddOid
    {
        my $configuration = shift;
        my $var = shift;
        my $key = shift;
        
        my $snmpagent = $configuration->{'snmpagent'};
        my $snmp = $configuration->{'snmp'};
        if ( $snmp->{"$key"} ){
            my $value = $var->{$key};
            if ( $snmp->{$key}->{'postprocess'} ) {
                $value =~ /(.*)/;
                $value=eval( $snmp->{$key}->{'postprocess'} );
            }
            $self->add_oid_entry("$snmpagent->{'rootoid'}.".
                                  "$snmpagent->{'enterpriseoid'}.".
                                  "$snmpagent->{'rpimonitoroid'}.".
                                  $snmp->{$key}->{'id'}, 
                                  $snmp->{$key}->{'type'}, 
                                  $value);
        }
    }
 
    my $configuration = $self->{'configuration'};
    my $var = $self->{'static'};
    foreach my $key (keys %{$var}) {
        AddOid($configuration, $var, $key);
    }
    $var = decode_json($self->{'configuration'}->{'sharedmem'}->fetch());
    foreach my $key (keys %{$var}) {
        AddOid($configuration, $var, $key);
    }
}

sub Run 
{
    my $this = shift;
    my $configuration = shift;
    my $static = shift;

    my $extsnmp = SNMP::Extension::PassPersist->new(
        backend_collect => \&UpdateTree,
        refresh         => 10,      # refresh every 10 sec
    );
    $extsnmp->{'configuration'} = $configuration;
    $extsnmp->{'static'} = $static;
    $extsnmp->run;
}

package main;
use strict;
use POSIX;
use Sys::Hostname;
use File::Basename;

sub help
{
  die <<EOF;
NAME
  rpimonitord

USAGE
  rpimonitord [-a address][ -b pidfile][[-c configuration_file]...]
     [-d delay][-h][-k][-l logfile][-m][-n][-p port][-r][-s][-t timeout]
     [-v[v[...]]][-V]

DESCRIPTION
  rpimonitord is designed to extract data from GNU/Linux system and
  store statistic into RRD. rpimonitord embed a web server allowing
  to display current status and statistics.

OPTIONS
  -a, --addr        Web server bind address (Default: 0.0.0.0)
  -b, --background  Define the pid file when run in background
  -c, --conf        Define the configuration file
                      Default: /etc/rpimonitor/data.conf
                               /etc/rpimonitor/daemon.conf
  -d, --delay       Delay between check ins seconds (Default: 10)
                      Note: If you want to change the default delay, the
                      rrd file will have to be deleted rpimonitord will
                      recreate them at next startup with the new time slice.
  -h, --help        Shows this help and exit
  -i, --interactive Interactive configuration helper
  -k, --keep        Keep log file (Default: logfile is delete at each start)
  -l, --logfile     Logfile (ex: /var/log/rpimonitor.log)
  -m, --mib         Get MIB for current configuration
  -n, --noserver    Don't start embeded web server
  -p, --port        Web server port (Default: 8888)
  -r, --readonly    Read only mode. Do not generate json nor RRD. This feature 
                    can be used to collect KPI and get them through snmp.
  -s, --show        Show configuration as loaded and exit
  -t, --timeout     KPI read timeout in seconds (Default: 5)
  -v, --verbose     Defines log level
  -V, --Version     Show version and exit

CONFIGURATION
  Configuration can be defined into etc/rpimonitor/daemon.conf and
  /etc/rpimonitor/data.conf or in a list of files specified by -c parameter.
  In /etc/rpimonitor/template/*.conf provided at installation you can
  see how to customize rpimonitord.
  Configuration defined inside a configuration file always overwrite
  default values.
  Configuration given as option of the command line always overwrite
  the one defined into a file.
  ** Warning: Be sure to use Linux filefeed format with line ending
  with LF (and not CR/LF like in Windows) **

SNMP
  RPi-Monitor can act as snmp-agent. Configuration of OIDs are done in 
  configuration file. Refer to man page for details.
  To add rpimonitord-snmp as snmp agent, add the following line to your 
  snmpd.conf and configure secutiry access appropriately:
   
    pass_persist .1.3.6.1.4.1.54321 /usr/bin/rpimonitord-snmp

RAW DATA ACCESS
  Once RPi-Monitor is started the data representing the current status
  are available in json format and can be downloaded from the root of
  the web interface (ex: http://RpiAddress:8888/static.json)
    static.json:    Static information extracted at startup
    dynamic.json:   Current values of dynamic information extracted
                    periodically
    menu.json:      Description of menus when multiple pages are
                    configured

  The web interface configuration can also be downloaded in json format:
    statistics.json: Description of statistics page
    status.json:     Description of status page
    friends.json:    List of friends
    addons.json:     List of addons

  Statistic information are stored into RRD file available in the
  directory /var/lib/rpimonitor/stat/

AUTHOR
  Xavier Berger
    http://rpi-experiences.blogspot.fr

EOF
}

sub writePID {
  open(PID, ">> $pidfile") || die "Could not open '$pidfile' $!";
  print PID "$$ ";
  close(PID);
}

sub daemonize {
  my $configuration = shift;
  chdir '/' or die "Can't chdir to /: $!";
  open STDIN, '/dev/null' or die "Can't read /dev/null: $!";
  open STDOUT, '>>/dev/null' or die "Can't write to /dev/null: $!";
  open STDERR, ">>$configuration->{'daemon'}->{'logfile'}" or die "Can't write to $configuration->{'daemon'}->{'logfile'}: $!";
  defined(my $pid = fork) or die "Can't fork: $!";
  exit if $pid;
  setsid or die "Can't start a new session: $!";
  umask 0;
}

sub StartServer
{
  #start server as a separate process with specific user right (user:pi)
  my $configuration = shift;
  my $monitor = shift;
  my $serverpid;
  unless ( $configuration->{'daemon'}->{'noserver'} ){
    unless ($serverpid = fork) {
      $pidfile and writePID();
      my $server = Server->new();
      $server->Run($configuration,$monitor);
      exit;
    }
  }
  return $serverpid;
}

my $configuration = Configuration->new();

sub stop
{
  $configuration->{'daemon'}->{'delay'} = 0;
}

sub interactive
{
  my $interactive = Interactive->new();
  $interactive->Run();
}

$configuration->{'daemon'}->{'logfile'} = "";
# read command lines
while($_ = shift)
{
  /-a(ddr)?/        and $configuration->{'daemon'}->{'addr'} = shift and next;
  /-b(ackground)?/  and $pidfile = shift and next;
  /-c(onf)?/        and push @{$configuration->{'daemon'}->{'confFiles'}}, shift and next;
  /-d(elay)?/       and $configuration->{'daemon'}->{'delay'} = shift and next;
  /-h(elp)?/        and help;
  /-i(nteractive)?/ and interactive() and exit;
  /-k(eep)?/        and $configuration->{'daemon'}->{'keeplogfile'}++ and next;
  /-l(ogfile)?/     and $configuration->{'daemon'}->{'logfile'} = shift and next;
  /-m(ib)?/         and $configuration->{'getmib'}++ and last;
  /-n(oserver)?/    and $configuration->{'daemon'}->{'noserver'}++ and next;
  /-p(ort)?/        and $configuration->{'daemon'}->{'port'} = shift and next;
  /-r(eadonly)?/    and $configuration->{'daemon'}->{'readonly'}++ and next;
  /-s(how)?/        and $configuration->{'show'}++ and next;
  /-t(imeout)?/     and $configuration->{'daemon'}->{'timeout'} = shift and next;
  /^-([v]+)$/       and $loglevel = length $1 and next;
  /-V(ersion)?/     and die "$0 version $VERSION\n";
}

$configuration->{'daemon'}->{'keeplogfile'} or -f $configuration->{'daemon'}->{'logfile'} and unlink $configuration->{'daemon'}->{'logfile'};
$configuration->{'daemon'}->{'logfile'} ||= '/dev/null';

if ( ! $pidfile ) {
  if ( ! ($configuration->{'daemon'}->{'logfile'} =~ /\/dev\/null/) ){
    open my $logfile, '>>', $configuration->{'daemon'}->{'logfile'};
    *STDERR = $logfile;
  }
};

$configuration->Load();

if ($configuration->{'getmib'}) {
  my $snmpmodule = SnmpModule->new();
  $snmpmodule->GetMib($configuration);
  exit;
}

my $monitor = Monitor->new();
# Process data that should be extracted once, before the server starts
$monitor->Process($configuration,'static');
$monitor->{'static'}->{'hostname'} = hostname();

# snmp agent 
if ( basename($0) =~ /rpimonitord-snmp/ ) {
  #  $Data::Dumper::Indent = 1;
  #  print Data::Dumper->Dump([$monitor->{'static'}]);
  my $snmpmodule = SnmpModule->new();
  $snmpmodule->Run($configuration,$monitor->{'static'});
  exit;
}

$pidfile and &daemonize($configuration);

$SIG{INT}    = sub { stop(); }; # catch Ctrl+C

my $serverpid;

# Manage loglevel
$SIG{USR1}   = sub { ($loglevel < 5 ) and ++$loglevel and print STDERR "[", strftime("%Y/%m/%d-%H:%M:%S", localtime), "] Change loglevel to ", $loglevel ,"\n"; };
$SIG{USR2}   = sub {  $loglevel       and $loglevel-- and print STDERR "[", strftime("%Y/%m/%d-%H:%M:%S", localtime), "] Change loglevel to ", $loglevel ,"\n"; };

print STDERR "[", strftime("%Y/%m/%d-%H:%M:%S", localtime), "] ", "RPi-Monitor has been started with loglevel set to $loglevel\n";
print STDERR "                      Log level can be increased or decreased during runtime\n";
print STDERR "                      by sending signal USR1 or USR2 with the command killall -USRx rpimonitord\n";

my $startTime = 0;
for (;;) {
  my $currentTime=mktime(localtime());
  ( $currentTime - $startTime ) < 2 and die "rpimonitord stopped because respawning too fast.\n";
  $startTime = $currentTime;
  if ( $pidfile ) {
    -f $pidfile and unlink $pidfile;
    writePID();
  }

  $serverpid = StartServer($configuration,$monitor);
  #Start process respawner
  if ( my $procpid = fork() ) {
    waitpid($procpid,0);
  }
  else{
    $pidfile and writePID();
    $monitor->Run($configuration, $serverpid);
    exit(0);
  }
  $serverpid and kill (9,$serverpid);
  $configuration->{'daemon'}->{'delay'} or last; #delay == 0, it means we should stop the process.
}
